
Otras opciones de despliegue:
https://www.udemy.com/course/react-cero-experto/learn/lecture/19807106#questions/18287464


	--	Notas Curso: React: De cero a experto ( Hooks y MERN ) 	--

- Sitio de Babel:   https://babeljs.io/


- Seccion 3: Intro a JavaScript Moderno


// Ejemplo de crear proyecto de React usando Vite
PS C:\Users\Escritorio\react-0-a-experto> npm create vite@latest
√ Project name: ... 02-intro-javascript   //definir nombre del proyecto
√ Select a framework: » React		//Elegir React
√ Select a variant: » JavaScript	//Elegir JavaScript

Done. Now run:    
  cd 02-intro-javascript  //Entrar a la carpeta del proyecto creado
  npm install     	  //Instalar las dependencias
  npm run dev 		  //Levantar el proyecto


- Recursos
-- Bases de JavaScript
https://create-react-app.dev/

-- Arreglos
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/map

-- Desestructuracion de objetos
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

-- Import, export y funciones comunes en arreglos
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array/find
https://gist.github.com/Klerith/4aeb99d31aedbc29ff4d54bbb77d2d7f

-- Promesas 
https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise

-- Fetch API
https://developers.giphy.com/  
// para crear API: 
 https://developers.giphy.com/dashboard/  -- clic create an API key -→ clic API 
-→ agregar nombre y descripcion -> creacte app -> copiar el API Key y pegar en nuestro proyecto de VSC: VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0
-> ir a docs -> API -→ Endpoints -→ Buscar en el Menu: Random Endpoint
copiar la url de GIF URL en el navegador: api.giphy.com/v1/gifs/random
luego darle enter y
luego pegar en el navegador el apikey:  ?apikey=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0

Ruta de la API queda asi: https://api.giphy.com/v1/gifs/random?apikey=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0
--La informacion que  interesa esta dentro de data e images original

https://developer.mozilla.org/es/docs/Web/API/Fetch_API

- Temas principales de JavaScript: https://developer.mozilla.org/es/


------ Seccion 4: Primeros pasos en React   ------

Instalar prop-types para validar las props que se reciben del padre
- instalar en la consola ruta de la app: npm i prop-types

- Para validar las props con propTypes realizamos lo siguiente:

- Importar la libreria: 
import PropTypes from 'prop-types'

- Revisar las props que se importan desde el padre
export const FirstApp = ({title, subtitle}) =>{ //props importadas

-Hasta el final del documento validar las props:

//Definir los props por defecto en caso de que no viene del padre pero si viene tomará la del padre
FirstApp.defaultProps = {
    title: 'Soy Goku',
}

//Validar las props que se recibe del padre cumpla con el tipo de dato requerido
FirstApp.propTypes ={
    title: PropTypes.string.isRequired,
    subtitle: PropTypes.string.isRequired,
}


Para ordenar líneas de código de forma ascendente en Visual Studio Code,

1) Abre el archivo que contiene el código que deseas ordenar.

2) Selecciona las líneas de código que deseas ordenar. Puedes seleccionarlas 
	manualmente o usar el atajo de teclado Ctrl + A (Windows/Linux) o 
	Cmd + A (Mac) para seleccionar todo el contenido del archivo.

3) Una vez seleccionado el código, presiona F1 o Ctrl + Shift + P (Windows/Linux) o 
	Cmd + Shift + P (Mac) para abrir la barra de comandos.

4) Empieza a escribir "Sort Lines" en la barra de comandos. A medida que escribas, 
	verás sugerencias de comandos relacionados.

5) Deberías ver una opción llamada "Sort Lines Ascending" en la lista de sugerencias.
	 Selecciónala.

¡Listo! Las líneas seleccionadas se ordenarán en orden ascendente basado en su contenido.


	------- Seccion 5: Pruebas unitarias y de integracion  -------

-- Si el proyecto fue creado por npx create react-app app ya tiene instalado libreria para pruebas
-- Como el  proyecto fue creado con Vite + React no trae instalado librerias para prueba por
lo que procedemos a instalarlos. Y realizar la siguiente configuracion.
-- Ir a al sitio de Jest que es una framework para hacer pruebas para proyectos con JavaScript
como react, node, angular, etc.

-- Ir al sitio de -> https://jestjs.io/  -→ ir a Getting Started -→
-> copiar: npm install --save-dev jest -> y pegarlo en la consola en la
ruta de la aplicacion para instalar jest.
-> Luego ir al package.json para ver que se instalo Jest. ->
-> en Package.json  en la parte de: "scripts": agregar: "test": "jest" 
-> Otra opcion es agregar en Package.json "test": "jest --watchAll" para poder ver los estados.
-> para ejecutar la aplicacion escribir en consola: npm run test

-> Dentro de la carpeta del proyecto a nivel de src Crear una carpeta llamada tests
Esta sera para pruebas un espejo de todas las carpetas y los archivos de la carpeta src.
Los archivos de test deben tener la extension: .test.js para archivos javascript y
para los archivos o componentes de react debe tener la extension: .test.jsx
ejemplo: 02-template-string.test.js
-- No se puede hacer pruebas a un archivo que no este exportado: export

-- Para poder tener ayuda en como se escribe las funciones de jest se debe instalar
instalar en consola de la ruta de la app: npm add -D @types/jest

-- Debido a que el proyecto fue creado con Vite para las pruebas se debe de 
Instalar la configuracion de Babel para test en la ruta del proyecto. 
--> ejecutar: npm install --save-dev babel-jest @babel/core @babel/preset-env
-- Crear un archivo dentro del proyecto a nivel de src: babel.config.cjs
-> dentro del archivo babel.config.cjs agregar la siguiente configuracion:
	module.exports = {
    presets: [
        ['@babel/preset-env', { targets: {esmodules:true}}],
        ['@babel/preset-react', { runtime: 'automatic'}],
    ],
  };


Nota:
Extensión de archivos
Configuración para las pruebas de nuestros distintos archivos, en caso de ver 
el error "You appear to be using a native ECMAScript module configuration file, 
which is only supported when running Babel asynchronously."

Cambiar extensión de los archivos jest.config.js y babel.config.js a .cjs
Para ver mas detalles al respecto pueden ir a 
https://nodejs.org/docs/latest/api/modules.html#enabling.

-- Para ejecutar las pruebas
-- ejecutar: npm run test  -> presionar w -> precionar p -> escribir el nombre de
archivo "02-template-string" a ejecutar a probar. esto para solo ejecutar este archivo.

//Nota: Para las pruebas lo que se tiene que hacer es ejecutar la funcion y
evaluar el valor de retorno si es el esperado.

--- PARA FETCH API - Nota para versiones menores a 18 en node realizar esta configuracion, 
las versiones mayores a 18 ya lo traen
--Crear un archivo: jest.config.cjs dentro del proyecto al nivel de la carpeta src
--Crear un archivo: jest.setup.js dentro del proyecto al nivel de la carpeta src
--- Dentro del archivo: jest.setup.js agregar: import 'whatwg-fetch';

-- instalar en la ruta de la app: npm add -D whatwg-fetch
-- instalar en la ruta de la app: npm add -D jest-environment-jsdom  o npm install -D jest@29.5
-- instalar en la ruta de la app: > npm add -D @babel/preset-react

-- Dentro del archivo jest.config.js agregar:
	module.exports = {
		testEnvironment:'jest-environment-jsdom',
    		setupFiles:['./jest.setup.js'],
  	};


//Para pruebas de los componentes en React instalar:

-Jest: es mas enfocada para hacer aserciones validaciones de funciones
-ir -> https://jestjs.io/ -> docs -> Framework Guides -> Testing React Apps -> 
-- Hasta abajo del documento nos describe que se debe usar Testing Library e indica como instalarlo.

- Testing Library: es muy bueno para manejar el DOM virtual, automaticamente hace los clic en botones, hacer interacciones, etc
- ir al sitio -> https://testing-library.com/ ->menu -> Frameworks -> React Testing Library: https://testing-library.com/docs/react-testing-library/intro
-- Instalar en ruta de la app: npm install --save-dev @testing-library/react

--La extension para los archivos de pruebas para components en React es: .test.jsx -> FirstApp.test.jsx


#### Seccion 6 - gif-expert-app
Recurso:https://legacy.reactjs.org/docs/strict-mode.html

PS C:\Users\Hp01\Escritorio\React-0-a-experto> npm create vite       
√ Project name: ... 04-gif-expert-app
√ Select a framework: » React
√ Select a variant: » JavaScript
Done. Now run:
  cd 04-gif-expert-app
  npm install      
  npm run dev     


Para cambiar el puerto tienes que ir al archivo de vite.config.js y colocarlo de la siguiente manera:
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  }
})


//Crear un API en el sitio: https://developers.giphy.com/

https://developers.giphy.com/  
// para crear API: 
 https://developers.giphy.com/dashboard/  -- clic create an API key -→ clic API 
-→ agregar nombre y descripcion -> creacte app -> copiar el API Key y pegar en nuestro proyecto de VSC: VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0
-> ir a docs -> API -→ Endpoints -→ Buscar en el Menu: Random Endpoint
copiar la url de GIF URL en el navegador: api.giphy.com/v1/gifs/random
luego darle enter y
luego pegar en el navegador el apikey:  ?apikey=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0

Ruta de la API queda asi: https://api.giphy.com/v1/gifs/random?apikey=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0
--La informacion que  interesa esta dentro de data e images original

https://developer.mozilla.org/es/docs/Web/API/Fetch_API


Recursos:
https://es.legacy.reactjs.org/docs/faq-structure.html
https://hackernoon.com/structuring-projects-and-naming-components-in-react-1261b6e18d76
https://gist.github.com/Klerith/e4fca6ac127ccb9abd1e8ad77fcd52f1


--- Traer Gifs 
--Probar en Postman:
GET: api.giphy.com/v1/gifs/search  -- Error 404 necesita el ?api_key
GET: api.giphy.com/v1/gifs/search?api_key=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0  --Status 200 ok falta especificar que gif buscar al final de la url agregar "&q=NOMBRE_DEL_GIF" 
GET: api.giphy.com/v1/gifs/search?api_key=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0&q=valorant&limit=20 //se agrego limite = 20

    const url = ` http://api.giphy.com/v1/gifs/search?api_key=VGTFsHDEQDQ3G5w9D5Rax75tZaljPOG0&q=${category}&limit=20`;
      


-- Demostracion de Produccion Rapido
-- Abrir el package.json -> ver el comando en: scripts -> build
-- Ejecutar en consola en la ruta de la app: npm run build
-- Luego revisar la carpeta "dist" dentro del proyecto. Y ahi se encuentra la app de produccion optimizada:
	dentro de la carpeta "dist" esta la carpeta assets y el archivo index.html y la imagen vite.svg 
	estos archivos son los que se tomarian y se subirian a un hosting

- http-server: a simple static HTTP server
-- Para subir el proyecto un servidor local
ir al link: https://www.npmjs.com/package/http-server

-- Globally via npm - Instalar usando CMD:   npm install --global http-server
luego estando en consola: entrar o hacer un cd a la carpeta dist del proyecto.
 cd C:\Users\Hp01\OneDrive\Escritorio\React-0-a-experto\04-gif-expert-app\dist   
luego:  http-server -o   //para que abra nuestro proyecto en produccion(simulacion) 


## Seccion 7 Deploy en Github
-- Ejecutar: git checkout -- .   //Para rehacer el estado de nuestro codigo de la app hasta el ultimo commit

-- Ejecutar en consola en la ruta de la app: npm run build
-- Luego revisar la carpeta "dist" dentro del proyecto. 
-> Renombrar la carpeta "dist" a "docs" 
-> Entrar al archivo index.html de la carpeta docs para editar lineas de codigo. Agregarles un punto antes de la ruta.
    <script type="module" crossorigin src="./assets/index-DuLSGigz.js"></script>
    <link rel="stylesheet" crossorigin href="./assets/index-DQ2fAogY.css">

->Ir a github -> entrar al repositorio del proyecto ->Clic en settings 
-> Clic en page -> Elegir la rama main -> Elegir folder: /docs ->clic en save. →Listo

## Seccion 8 - Pruebas de 04-gif-expert-app
//screen.debug(); //muestra en pantalla el component que se esta evaluando con sus datos que se ingresan

Datos:
<form 
	onSubmit={onSubmit} 
	aria-label="form" //es su key para cuando se hacen pruebas
>


### Seccion 9 - Profundizando Hooks - Generales

- App creada: npm create vite -> √ Project name: 05-hook-app ->React->JavaScript

//Recursos
//Libreria para form de React
https://react-hook-form.com/get-started
//Libreria sobre cache en react
https://tanstack.com/query/latest
//Curso gratuito para manejar tanstack query en react
https://fernando-herrera.com/course/react-query/
Referencia de la API de los Hooks
https://es.legacy.reactjs.org/docs/hooks-reference.html#uselayouteffect

//Hook ref:Permite mantener una referencia y cuando esa referencia cambie no disparemos 
una rerenderizacion de nuestro componente //tambien mantiene una referencia a un elemento html
    const ref = useRef();

//memo es una funcion que le dice a React memoriza este component y solo cuando las properties cambien se va a ejecutar este componente
//El hook UseCallback (parecido memo) sirve para memorizar funciones, y lo que regresa es una funcion que se puede ejecutar pera esa funcion memorizada solo se va a ejecutar cuando algo cambie
  


//Api para pokemon
https://pokeapi.co/
Peticion: https://pokeapi.co/api/v2/ Escribir: pokemon/1

En Postman: GET: https://pokeapi.co/api/v2/pokemon/1


----------   #Seccion 10: Profundizando Hooks - useReducer	----------
Un reducer no es mas que una funcion pura
Recursos: 
https://es.legacy.reactjs.org/docs/hooks-reference.html#usereducer
https://www.youtube.com/watch?v=hb8O0qRqiSk&t=2s


----------   #Seccion 10: Profundizando Hooks - useContext
Context - Un contenedor de informacion que se encuentra en un nivel superior
que le va a permitir a los componentes hijos de el poder leer y ejecutar metodos
que se encuentren dentro de Context.
 
https://reactrouter.com/en/main
https://reacttraining.com/react-router/web/api/NavLink
https://reacttraining.com/react-router/web/guides/quick-start
https://reactrouter.com/en/main/start/tutorial

Instalar React Router DOM - Para rutas: 
   ->	npm install react-router-dom


Version 6.22.3:

1. Lo primero es crear en la carpeta raíz (src) un archivo que se llame Routes.jsx con el siguiente código

Routes.jsx

import { Navigate, createBrowserRouter } from "react-router-dom";
import { About, Home, Login, MainApp } from "./09-useContext/index"
 
export const getRoutes = () => createBrowserRouter([
    {
        path: "/",
        element: <MainApp />,
        children: [
            {
                path: "/",
                element: <Home />,
            },
            {
                path: "login",
                element: <Login />,
            },
            {
                path: "about",
                element: <About />,
            },
            {
                path: "*",
                element: <Navigate to="/" replace />
            }
        ]
    }
]);
 

Pueden ver que yo cree un archivo de barril para manejar las importaciones
2. El código del  main.jsx queda de la siguiente manera:

main.jsx

import React from 'react'
import ReactDOM from 'react-dom/client'
import { RouterProvider } from "react-router-dom";
import './index.css' 
import { getRoutes } from './Routes';
 
const router = getRoutes();
 
ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <RouterProvider router={ router } />
  </React.StrictMode>
)
Como pueden ver, el getRoutes se encarga de pasar todas las rutas al main para tener el código de una manera más simple y más fácil de leer

3. Finalmente, el archivo MainApp.jsx  (que se ubica en 09-useContext) queda de la siguiente manera

MainApp.jsx

import { Outlet } from "react-router-dom"
import { Navbar } from "./index"
import { UserProvider } from "./context/UserProvider"
 
export const MainApp = () => {
  return (
    <UserProvider> 
      <Navbar />
      <hr />
 
      <div>
        <Outlet />
      </div>
 
    </UserProvider>
  )
}
La función del Outlet es indicarle a React donde va a renderizar el resto de archivos o los Children
El resto del código es tal cual como se ve en las lecciones
Nuevamente, les recomiendo que chequen la documentación para que entiendan de mejor manera cada parte del código, el ejemplo que se usa en la documentación es muy bueno


-- Pruebas
render(): se utiliza para probar componentes de React. Te permite renderizar un componente en un entorno de prueba y verificar su salida, como el HTML generado o los eventos disparados.
renderHook(): se utiliza para probar los hooks de React de forma aislada. Te permite renderizar un hook dentro de un componente de prueba y verificar su comportamiento, como el estado interno o las funciones que actualiza.


--- S14 - HeroesApp - Single page Application(SPA)

Recursos:
https://reactrouter.com/en/6.4.4/start/tutorial#setup
https://www.youtube.com/watch?v=FR7x0tqwafc
https://reactrouter.com/en/main
https://gist.github.com/Klerith/566b484ac6fe46c8fa949e61df671a18
https://animate.style/
https://github.com/Klerith/custom-hooks/blob/main/useForm/useForm.js

Aporte CSS hecho con Tailwind: https://www.udemy.com/course/react-cero-experto/learn/lecture/19946236#questions/17111398
https://tailwindcss.com/docs/installation


--Archivos de como configurar Routes:
https://gist.github.com/ZadkielMouz/62f92203458e3ba5dd6b0c04ad87d09a

Bootstrap en index.html -Copia el CDN
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

Agrego estilos css en index.html -Copia el CDN: https://animate.style/  
<link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  />

Install:
npm install react-router-dom   //para las rutas
npm install query-string  //para manejar enviar query params en la ruta al buscar un heroe y enviarle el nombre en la url
npm install query-string@7.1.3 //recomendable instalar esta version para evitar error cuando se hacen los tests



#### Seccion 16 - pruebas a la app heroes

// https://github.com/Tech-Code1/heroes-app-react
//https://github.com/ArmandoRamirezCarrillo/HeroesApp


Se debe de agregar transformIgnorePatterns a jest.config

module.exports = {
  transformIgnorePatterns: [
    'node_modules/(?!(query-string|decode-uri-component|split-on-first|filter-obj)/)',
  ],
  testEnvironment: 'jest-environment-jsdom',
//  setupFiles: ['./jest.setup.js'],
};


///Para las pruebas de rutas - pruebas en AppRoute.test.js
Instalar:
La versión usada para tests, en este caso v7, la instalaremos como dependencia y con un alias para poder tener las dos versiones en paralelo:

   npm install -D query-string-v7@npm:query-string@7.1.3

Ahora en el archivo jest.config.ts añadiremos la opción moduleNameMapper en nuestra configuración:

export default {
    testEnvironment: 'jsdom',
    moduleNameMapper: {
      "^query-string$": "<rootDir>/node_modules/query-string-v7"
    }
  };

		## Seccion 17 - JournalApp-MaterialUI -Estructura y Diseño
Install:
- npm install react-router-dom   //para las rutas
- Instalar Material UI 
-> npm install @mui/material @emotion/react @emotion/styled

La interfaz de usuario de Material utiliza la fuente Roboto de forma predeterminada.
-> Agregar en index.html en el <head> la fuente de Roboto font usada por material UI
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
/>

## Agregar los Icons de material UI
-> npm install @mui/icons-material

- Luego de hacer las instalaciones de Material UI 
- Hacer configuraciones de material UI en vite: 
→ Se agrego en el proyecto la carpeta theme
 
- Ir a ver como se usa 
-> https://mui.com/material-ui/getting-started/usage/
-> https://mui.com/material-ui/getting-started/example-projects/
-> https://github.com/mui/material-ui/tree/next/examples/material-ui-vite

## Recursos: 
Material UI: https://mui.com/  
-> https://mui.com/material-ui/guides/minimizing-bundle-size/#development-environment).
-> https://mui.com/material-ui/getting-started/installation/


## Seccion 18 - Redux
- Redux : Es un contenedor predecible del estado de nuestra aplicacion.
-- Store: Fuente unica de la verdad - Ahi es donde esta la informacion que mis componentes consumiran

- Recursos:
-- Extension para el navegador:
-> https://chromewebstore.google.com/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en
-> https://redux-toolkit.js.org/
-> Snippet y Gists de Slice: https://gist.github.com/Klerith/060281f76f3b7f0a458e4b83b1fc0062


- Inicio de Proyecto - Redux-Tool
-> ir ->https://redux-toolkit.js.org/  
-> clic en Get Started -> https://redux-toolkit.js.org/introduction/getting-started
-> Quick Start -> Instalar -> npm install @reduxjs/toolkit react-redux

-> Instalar Axios para peticiones Http: npm install axios


- Configurar Store y Reducer
-- Crear un Snippet en VSC - Para que al Escribir reduxSlice aparezca la plantilla a editar el Slice
-> en VSC -> Precionar: CTRL+SHIF+P -> escribir: >configure User Snippets 
-> Elegir el lenguaje: javascript ->
-> Definirlo:
	 "Crear un slice de Redux": {
	 	"prefix": "redux-slice",
	 	"body": [
	 		"AQUI VA EL CODE, cada linea va dentro de comillas",
	 	],
	 	"description": "Crear un slice de Redux"
	 }
}


//Ejemplo Mas general - Agrega el nombre del archivo por default

"RTK Slice": {
  "prefix": "redux-slice",
  "body": [
    "import { createSlice } from '@reduxjs/toolkit'",
    "",
    "const initialState = {$0}",
    "",
    "export const ${1:${TM_FILENAME_BASE}} = createSlice({",
    "  name: '${TM_FILENAME_BASE/(Slice)//}',",
    "  initialState,",
    "  reducers: {}",
    "})",
    "",
    "// export const {} = ${1:${TM_FILENAME_BASE}}.actions",
    "export const ${TM_FILENAME_BASE/(Slice)//}Reducer = ${1:${TM_FILENAME_BASE}}.reducer",
    ""
  ],
  "description": "Creates a Redux Slice",
}


//Este es el mi Snippet

{
	// Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

"Crear un slice de Redux": {
	"prefix": "redux-slice",
	"body": [
		"import { createSlice } from '@reduxjs/toolkit';",
		"",
		"const initialState = {",
		"	counter: 10,",
		"}",
		"",
		"	export const ${1:${TM_FILENAME_BASE}} = createSlice({",
		"		name: '${TM_FILENAME_BASE/(Slice)//}', //nombre del slice",
		"		initialState,",
		"		reducers: {",
		"",
		"		//Definir las funciones",
		"			increment: (state) => {",
		"				state.counter += 1;",
		"			},",
		"			//incrementa en 2 en 2 o segun el valor enviado de parametro (action.payload)",
		"			incrementBy : (state, action) => {",
        "			state.counter += action.payload;",
    	"			},"
		"",
		"		}",
		"	});",
		"",
		"",
		"// Action creators are generated for each case reducer function",
		"// Exporta las funciones para que pueda ser utilizada por otros component",
		"export const { increment, incrementBy } = ${1:${TM_FILENAME_BASE}}.actions;",
	],
	"description": "Crear un slice de Redux"
}
}


//Cree un Snippet para Lenguaje javascript/React

{
		"Crear un arrow function component": {
	 	"prefix": "cafcomp",
	 	"body": [
	 		"export const ${1:${TM_FILENAME_BASE}} = () => {",
			"	return (",
			"		<>  ",  
			"		</>",
			"	)",
			"	}",
	 	],
	 	"description": "Crear un arrow function component"
	 }
}



snippet que hice para crear un archivo de barril
 
"Crear un archivo de barril": {
        "prefix": "barril",
        "body": [
                    "export * from '${1:archivo}'"          
        ],
        "description": "Crea un Fragmento de archivo de barril | personalizado por DR"



###PokemonAPI
♠ Go -> https://pokeapi.co/
https://pokeapi.co/api/v2/  - pokemon?limit=10&offset=0  
- Thunk es una accion asincrona que dispara otra accion cuando se resuelve la peticion asincrona.

--JSON - Recursos para peticiones Https simulaciones
https://jsonplaceholder.typicode.com
JSON de TODOS: https://jsonplaceholder.typicode.com/todos


## S19- Introduccion a Redux y autenticacion en firebase - 08-journal-app

Install Redux al Proyecto -> ir ->https://redux-toolkit.js.org/  
-> clic en Get Started -> https://redux-toolkit.js.org/introduction/getting-started
-> npm install @reduxjs/toolkit react-redux

-> Para validar formularios: https://www.npmjs.com/package/validator

--Configuracion Incial de Firebase:
- Usar variables de entorno.
Si se desea usar variables de entorno, con Vite se puede configurar de la siguiente manera:
- En la raiz del proyecto, crear el archivo .env
- Si no se desea subir a git, en el archivo   .gitignore agregar .env al final
- Dentro del archivo .env crear las variables, por ejemplo :

VITE_FIRESTORE_API=api
VITE_FIRESTORE_AUTH_DOMAIN=domain
VITE_FIRESTORE_PROJECT_ID=id
VITE_FIRESTORE_STORAGE_BUCKET=storage
VITE_FIRESTORE_MESSAGINGSENDERID=sender
VITE_FIRESTORE_APP_ID=app

- En el archivo config.js llamar a los valores de la siguiente manera:

const firebaseConfig = {
    apiKey: import.meta.env.VITE_FIRESTORE_API,

###Firebase:
-- Firebase es una plataforma Backend-as-a-Service (BaaS) proporcionada por Google que 
ofrece diversos servicios, como autenticación, bases de datos y almacenamiento en la 
nube, entre otros. Está diseñada para ayudar a los desarrolladores a construir y 
gestionar el backend de sus aplicaciones sin tener que administrar servidores o 
infraestructura. Firebase puede utilizarse como una solución de backend independiente 
o en conjunto con otras tecnologías de backend como Node.js.
-- Se recomienda para casos en los que se desea construir y gestionar el backend de la 
aplicación de forma rápida y sencilla, sin tener que administrar servidores o 
infraestructura. También es una buena opción si se necesita añadir autenticación y 
gestión de usuarios a la aplicación, ya que proporciona una forma simple y segura de 
gestionar cuentas de usuario.


- Ir a Firebase:
->clic en console: https://firebase.google.com/docs/web/modular-upgrade?hl=es-419 
->Logearse con la cuenta de google -> Usar la capa gratuita.
-> Clic Agregar Proyecto -> Agregar nombre: journal-app-react
-> Deshabilitar Google Analytics -(el proyecto no lo necesita)
-> Clic en crear Proyecto. ->Entrar al proyecto 
-> clic en el icon: </> ->  Para agregar firebase a al App 
-> Dar nombre a la App: Journal-App -> no activar Firebase Hosting

->Instalar Firebase al proyecto -> npm install firebase
->dentro de src/firebase/config.js Copiar la configuracion al proyecto que ofrece firebase

-- Agrega tu primer método de acceso y comienza a utilizar Firebase Auth
->Dentro de nuestra App -> Elegir productos a agregar a la App 
->clic en Authentication -> clic en comenzar 
->elegir:Correo Electronico/Contraseña y clic en Habilitar. (no habilitar acceso sin contraseña) -> Guardar
->clic en Agregar nuevo Proveedor -> Google -> Habilitar ->Agregar nuestro email -> Guardar

->Listo configuracion de autenticacion realizada con exito: 
->Los usuarios authenticados se veran dentro de Authenticaction -> Usuario
->Documentacion: https://firebase.google.com/docs/auth/web/google-signin?authuser=0&hl=es

#### Se agrego animacion a las paginas de la aplicacion
->Animaciones: -> https://animate.style/
->Opcion 1: Instalar: npm install animate.css --save
->Opcion 2: using a CDN: Pegar en index.html dentro del head ->
	<head>
  		<link
    		rel="stylesheet"
    		href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"
  		/>
	</head>


- S20- JournalApp-Redux-CRUD en Firestore y subida de archivos

#### Prepara la base de datos - cloudFirestore

->Ir al proyecto Journal-app-react en Firestore y 
-> elegir el producto: CloudFirestore -> Firestore Database -> Crear Base de datos
-> Elegir ubicacion(por defecto) 
-> Elegir Modo de Produccion(se debe estar autenticado(allow read, write:)), el modo de prueba(para no autenticado) -> 
-> Creada la BD -> clic en inciar coleccion -> Proceso de lo que se hara desde la App
-> Estructura de la BD: id-user1(coleccion) ->Journal(documento) ->notes(coleccion) ->documento(datos de la nota)

->Modificar las reglas de firebase para dejar pasar las peticiones si el user esta autenticado: request.auth != null;
->Clic en firestore Database->Reglas: modificar campo -> allow read, write: if request.auth != null;  -> Publicar

#### Se agrega SweetAlert 2 para notificaciones a la app -> https://sweetalert2.github.io/
->Instalar: npm install sweetalert2 
-> Importaciones:
	import Swal from "sweetalert2";
	import 'sweetalert2/dist/sweetalert2.css';
-> Codigo:

 useEffect(() => {
        if(messageSaved.length > 0){//valida que messageSaved no sea un String vacio '' para mostrar la alert
            Swal.fire('Nota actualizada', messageSaved, 'success');
        }
   }, [messageSaved])//se dispara cuando cambie el estado(texto o String vacio '') de messageSave

#### Cloudinary.com -> Backend para subir imagenes -> https://cloudinary.com/
//Firebase ofrece su propio Storage  para almacenar imagenes 
-> https://firebase.google.com/docs/reference/rest/storage/rest?hl=es-419.

->Ir a https://cloudinary.com/ ->Logearse con correo de Google ->ir a Dashboard ->
-> Apartado de Product Environment -> Encontraremos:
-> Cloud name, e ir a -> Go to API Keys ->Encontraremos:
-> API Keys: que se usa para mandar a un frontend para identificar la app con cloudinary
->API Secret: se va a tener acceso a eliminar o agregar. modificar el almacenmiento en cloudinary
->API Environmet variable: se utiliza si estamos en un Backend (tiene todo el storage o almacenamiento en cloudinary

-> Apartado de Product Environment -> Upload -> bajar e ir a Upload presets: aparecen 2 opciones
->signed:necesitara autenticacion para subir imgs(backend), Unsigned: será publico cualquiera puede subir imgs con la url
->Empezamos a crear el Storage -> Clic en Add upload preset -> Se agrega los datos.
->Upload preset name: react-journal
->Signing Mode: unsigned
->asset folder: journal //Se define el directorio donde se guardarán las imgs
->Dejar las demas configuraciones por defecto -> clic en Save.


-> en Cloudinary -> clic en el icono de Asset -> Media Library ->Folders -> Estan las imagenes guardadas
-> Documentacion de subir imagen mediante postman: https://cloudinary.com/documentation/image_upload_api_reference

-> Abrir Postman: Metodo:POST https://api.cloudinary.com/v1_1/demo/image/upload
-> datos de la URL: demo:cloude name(code)
->
-> Abrir Postman: Metodo:POST https://api.cloudinary.com/v1_1/dnuomqvsk/upload
->En Postman -> Body ->Clic form-data -> KEY escribir file ->  VALUE:Select Files->(selecciona imgs) 
					-> KEY escribir upload_preset ->  VALUE: escribir: react-journal (nombre cloud)
->Clic en send ->Obtiene respuesta(datos de la img). secure_url contiene la url de la imagen que se subio al storage de cloudinary
-> la url de la imagen contiene el id de la imagen para modificarla(eliminar, saturar imagen, bordes, etc) su id es el bloque antes de .png (ycwjfnu52bpec03nh3wf)

{
    "asset_id": "c1afbaf07b3d9e2ca2c282a91d91fe20",
    "public_id": "ycwjfnu52bpec03nh3wf",
    "version": 1718923040,
    "version_id": "628eb013b13d21d7994f9d7b63c3cd39",
    "signature": "d11e35a97ee1c667839909d13f5921d8707e12d2",
    "width": 500,
    "height": 500,
    "format": "png",
    "resource_type": "image",
    "created_at": "2024-06-20T22:37:20Z",
    "tags": [],
    "bytes": 118476,
    "type": "upload",
    "etag": "00c823c81bbb4d859b1d9f1b2d2070dc",
    "placeholder": false,
    "url": "http://res.cloudinary.com/dnuomqvsk/image/upload/v1718923040/ycwjfnu52bpec03nh3wf.png",
    "secure_url": "https://res.cloudinary.com/dnuomqvsk/image/upload/v1718923040/ycwjfnu52bpec03nh3wf.png",
    "asset_folder": "journal",
    "display_name": "converso",
    "original_filename": "converso"
}

--Para ver la imagen en cloudinary: 
->Cloudinary -> clic icono Asset -> Media Library ->Folders -> Aparece folder: journal - Estan las imagenes guardadas

#### Nota deploy en Vercel
Si suben la app a Vercel y encuentran un problema al crear una nueva nota, pueden probar 
a solucionarlo agregando imageUrls: [] en el archivo store/journal/thunks.js 
en la función "startNewNote":

const newNote = {
    title: "",
    body: "",
    imageUrls: [],
    date: new Date().getTime()
};



####Seccion 21 - Pruebas con Redux, Firebase, Firestore y autenticacion

#####Recursos: 
->Cloudinary SDK-Delete image: https://cloudinary.com/documentation/admin_api#delete_resources

Para borrar las imagenes de los Test:
->instalar: npm install -D cloudinary
->instalar: npm install -D setimmediate
->instalar: npm install -D dotenv  --> Util para cargar las variables de entorno en el lado de NODE


- Se modifico el archivo: jest.setup.js  --para cargar las imgs
// En caso de necesitar la implementación del FetchAPI
import 'whatwg-fetch'; // <-- yarn add whatwg-fetch
import 'setimmediate'; // <-- para imagenes

- Se modifico el archivo: jest.config.cjs. Se agrego: transformIgnorePatterns: [],

module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js'],
    transformIgnorePatterns: [], 
}


#### Crear nuevo proyecto en Firebase para BD de testing
->Se utiliza el de platzblog -> crear proyecto->named: react-journal-test
->Deshabilitar Firebase Hosting ->Clic Registrar app

->Copiamos la configuracion: Y la pegamos en firebase/config que sera para el testing
->la otra sera para dev/prod

const firebaseConfig = {
  apiKey: "AIzaSyA_sp6L_I.....",
  authDomain: "platzblog-e....e.firebaseapp.com",
  projectId: "platzblog-e.......2",
  storageBucket: "platzblog-e........appspot.com",
  messagingSenderId: "22..........",
  appId: "1:22967911....:web:44d7ee7d84d500....",
  measurementId: "G-QDN2XN...4"
};

Luego ir al proyecto de platzBlog y dar clic CloudFirestore 
-> Clic en Firestore Database -> crear base de datos -> elegir modo produccion
-> clic en Reglas -> cambiar: allow read, write: if true; (todos podran leer y escribir) es para pruebas


const collectionRef = collection(FirebaseDB, `${uid}/journal/notes`);
const {docs} = await getDocs(collectionRef);
await Promise.all(docs.map(({ref}) => deleteDoc(ref)));


-- Variables de Entorno para configuracion de la BD
crear un archivo: .env   -> en el nivel de package.json
crear un archivo para test: .env.test   -> en el nivel de package.json

#### Para config de variables de entorno
->Crear archivo getEnvironments.js dentro de carpeta helpers. helpers/getEnvironments

->Modificar el archivo jest.setup.js aggregar:

	require('dotenv').config({
    		path: '.env.test'
	});

//mock para que cuando se haga una solicitud al archivo getEnvironments del lado del testing
//regresa la funcion getEnvironments  que regresa todas la variables de entorno que se encuentran definidas
	jest.mock('./src/helpers/getEnvironments', () => ({
    		getEnvironments: () => ({ ...process.env})
	}));


##### NOTA: Por seguridad no se recomienda subir las variables de entorno a github ser recomienda:
->Copiar el archivo: .env y crear otro llamado: .env.template 
-> El archivo .env.template tendra todas las variables de entorno necesarias, sin sus valores, 
-> para que las personas llenen los campos con sus data.
->Luego abrir el archivo: gitignore y agregar los archivos que contienen las variables de entorno 
->sencibles como: .env y .env.test(opcional) esto para que estos archivos no se puedan subir a GITHUB

VITE_HOLA=

VITE_APIKEY = 
VITE_AUTHDOMAIN=
VITE_PROJECTID=
VITE_STORAGEBUCKET=
VITE_MESSAGINGSENDERID=
VITE_APPID=


## Seccion 22: MERN Calendar - Estructura y Diseño

-- Instalaciones:
-> Instalar React Router DOM - Para rutas: ->	npm install react-router-dom
-> Add Bootstrap: Pegar el CSS CDN en el head del index.html -> 

Recursos:
->Estilos de LoginPage: https://gist.github.com/Klerith/74a0c4426599f3bc25b7f4e8d95b6a7f
->Para Font-awesome iconos ir a -> https://cdnjs.com/libraries/font-awesome
->copiar la version reciente(la primera) clic en "</>" y pegar en el head del index.html

->Calendario: https://www.npmjs.com/package/react-big-calendar  ->Usar: date-fns v2
-> instalar: npm i react-big-calendar     ->  npm i date-fns
-> Estilo del Calendario pegar como import: import 'react-big-calendar/lib/css/react-big-calendar.css'
-> calendar-messages-es.js -> https://gist.github.com/Klerith/1658fc368898dd673fc5a9a01ccb12ff

->Modal: 
->Diseño del Modal
->https://www.npmjs.com/package/react-modal   -> Instalar: npm i react-modal
->Code css del modal: https://gist.github.com/Klerith/5f490092ce9bd5775cb1d91162be0cea

->Contenido del Modal
->Selector de fechas en el form: https://www.npmjs.com/package/react-datepicker ->npm i react-datepicker
->Code html del form: https://gist.github.com/Klerith/8c9b2178830045b3f5126422bd0223e1

-> Para alertas SweetAlert2: npm i sweetalert2

->Instalacion de Redux Toolkit
-> clic en Get Started -> https://redux-toolkit.js.org/introduction/getting-started
-> Quick Start -> Instalar -> npm install @reduxjs/toolkit react-redux



//Forma de hacer la rutas con validacion
import {
  Navigate,
  RouterProvider,
  createBrowserRouter,
} from "react-router-dom";
import { LoginPage } from "../auth";
import { CalendarPage } from "../calendar";
 
const routes = [
  {
    path: "/auth/*",
    element: <LoginPage />,
  },
  {
    path: "/*",
    element: <CalendarPage />,
  },
];
 
export const AppRouter = () => {
  const authStatus = "not-authenticatedr";
 
  const router = createBrowserRouter([
    authStatus === "not-authenticated" ? routes[0] : routes[1],
    {
      path: "/*",
      element: <Navigate to={"/auth/login"} />,
    },
  ]);
 
  return (
    <>
      <RouterProvider router={router} />
    </>
  );
};




##Seccion 23: CalendarApp - Backend - Node, Express, Mongo

###Recursos:
->https://www.restapitutorial.com/httpstatuscodes


->Crear carpeta -> 10-calendar-backend ->Abri en VisualStudioCode -> abrir terminal -> 
->ejecutar: npm init -y (npm init) //instala dependencias en un proyecto de Node.js se crea el archivo package.json

->Forma 2:
-> abrir cmd -> ir a la ruta de la carpeta: 10-calendar-backend -> ejecutar: npm init -y

->Dentro de 10-calendar-backend. crear archivo: index.js: agregar: console.log('Hi mundo');
->Ejecutar archivo index.js:->abrir terminal en VSC(o cmd) ejecutar: node index.js 

->Nodemon ejecutara la aplicacion automaticamente cada vez que se halla realizado una modificacion.
-> Instalar Nodemon de forma global abrir cmd o powershell entrar en modo Administrador ->
-> npm i nodemon -g
->Ejecutar index.js con nodemon:->abrir terminal en VSC(o cmd) ejecutar: nodemon index.js 
-> Gracias a nodemon se podra modificar el index.js y se vera reflejado los cambios automaticamente en la terminal.
->precionar ctrl + c para detener la ejecucion.

->Configuracion para ejecutar Dev y Prod en package.json
->abrir package.json -> agregar en "scripts" los comandos a ejecutar
  "scripts": {
    "dev": "nodemon index.js",
    "start": "node index.js"
  },

->Ahora al ejecutar en la terminal:
->dev: npm run dev  //Se queda ejecutando el index.js y se mostrará los cambios automaticamente en la terminal.
->prod: npm start   //ejecuta el index.js 1 vez mostrando el resultado.
->precionar ctrl + c para detener la ejecucion.

###Express, es un framework para crear aplicaciones web, APIs y web services
-- Configurando Express para que se pueda crear un servidor que tenga los endpoint y ayude a la creacion del backend server
->Instalar Express, dentro de terminal de VSC ejecutar: npm i express    //instarlar version especifica: npm i express@4.17.4


--Configuracion del Backend Server:
const express = require('express'); //import express from 'express';

//crear el servidor de express
const app = express();

//Rutas
app.get('/', (req, res) => {
    res.json({
        ok: true
    })
});

//Escuchar peticiones
//Recibe el puerto en el cual se ejecutará, callback se ejecutará cuando el servidor express este arriba
app.listen(4000, ()=> { 
    console.log(`Servidor corriendo en puerto ${4000}`);
}) 

->Abrir el navegador o postman - GET: http://localhost:4000/   
->precionar ctrl + c para detener la ejecucion.

-> Dentro de: 10-calendar-backend -> Crear carpeta: public dentro de esta crear 
-> styles.css y index.html (dentro del head importar el archivo styles.css)

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./styles.css"
    <title>Demo App</title>
</head>
<body>
    <h1>bloqueado</h1>
</body>
</html>


-> use() en express es conocido como Un middleware que es una funcion que se ejecuta cuando 
-> alguien hace una peticion al servidor. -> Es una funcion que se ejecuta cuando pase por algun lugar
-> Middleware es una funcion que se va a ejecutar antes de cualquier otra cosa


#### Crear variables de entorno
->instalar: npm i dotenv
->Crear archivo: .env en el nivel de package.json

->Archivo .env  ->Agregar:  PORT=4000


->Agregar variables de entorno al archivo: index.js
const express = require('express'); //import express from 'express';
require('dotenv').config();

//console.log(process.env) //todos los procesos corriendo en el envirement-variables de entorno

//crear el servidor de express
const app = express();

//Directorio Publico
app.use(express.static('public'));

//Rutas
/* app.get('/', (req, res) => {
    res.json({
        ok: true
    })
}); */

//Escuchar peticiones
//Recibe el puerto en el cual se ejecutará, callback se ejecutará cuando el servidor express este arriba
app.listen(process.env.PORT, ()=> { 
    console.log(`Servidor corriendo en puerto ${process.env.PORT}`);
}); 


//Crear un nuevo Usuario:
->Postman ->POST: localhost:4000/api/auth/new  ->Elegir: Body ->raw -> 
-> JSON -> {"name":"Gerson", "email": "gerson@gmail.com", "password":"123456"}


//Express Validator 
-> npm i express-validator

//Configuracion de MongoDB
->Iniciar con Mongo -> https://www.mongodb.com/ ->Start free
->otra opcion: https://www.mongodb.com/es/cloud/atlas/efficiency?utm_source=google&utm_campaign=gs_americas_canada_search_brand_atlas_desktop&utm_term=mongo%20atlas&utm_medium=cpc_paid_search&utm_ad=e&gclid=Cj0KCQjwiYL3BRDVARIsAF9E4GfQWQYG_pbTlJA5eixJKM75IaFYqk4nUBlKe0iXkKn4kXc1HZmKSikaAtKzEALw_wcB
->Para la comunicacion de Node hacia Mongo: https://mongoosejs.com/


->Iniciar sesion en Mongo DB-> Elegir: DEVELOP & DEPLOY click -> Visit MongoDB Atlas
->Ir a: Database ->Cluster -> Create a cluster clic Build a Cluster ->Elegir opcion gratis Free
-> dar nombre al cluster: calendarDB ->dejar las Config. por defecto por defecto. -> clic Create Development o cluster
->(NOTA. Solo se permite tener 1 cluster Free - gratis Revisar si ya tenemos un cluster activo, 
-> si ya tenemos activarlo si no clic en Terminar para crear un nuevo Free.

-> Aun no crear el usuario y password para el Cluster, clic en pestaña: Database: 
->Esperar que se halla creado el cluster

->Cuando Aparece el Cluster: calendarDB -Creamos el Usuario y el password: -> Clic en pestaña DataBase Access
->Clic en ADD NEW DATABASE USER -> Seleccionar Password 
->Dar nombre del user: mern_user GMEP Y password: calendarDB+4numeros -> 
->Elegir Role: Read and write to any database -> click Add New User
->

###Conectarnos al Cluster usando: MongoDB Compass al que necesita user y password 
->Aparece el Cluster: calendarDB -> click en Connect -> clic Connect using MongoDB Compass
->Elegir la forma de conectse a mongoDB: 
->Seleccionar: Developer Tools, Compass(GUI) y Check I have installed Compass.  
-> NOTA: Si no se tiene instalado no checkear para que aparezca el link para instalar el mongoDB Compass
->Aparece las credenciales para conectarse:

1. Add your connection string to Compass
	mongodb+srv://gerson:<password>@calendardb.btmik1e.mongodb.net/
Replace <password> with the password for the gerson user. Ensure any option params are 
URL encoded.

-Abrir el programa MongoDB Compass
-> En URI agregar: mongodb+srv://mern_user:calendarDB+4numeros@calendardb.btmik1e.mongodb.net/


#### Conectar Node a Mongo Atlas
->Para la comunicacion de Node hacia Mongo: https://mongoosejs.com/
->Dentro del proyecto 10-calendar-backend instalar: npm i mongoose
->Configuracion de la conexion a la database desde Node a mongoDB: database/config.js
->la cadena de conexion se define en las variables de entorno en 
->el archivo .env -> se agrego: mern_calendar(es la BD de calendar)

PORT=4000
DB_CNN=mongodb+srv://mern_user:calendarDB+4numeros@calendardb.btmik1e.mongodb.net/mern_calendar


####Encriptar la contraseña
->Encriptar contraseña instalar: npm i bcryptjs

####Generar un JSON Web Token
->JWT tiene 3 partes el 
->HEADER[Tipo de algoritmo para encriptacion y tipo de JWT], 
->PAYLOAD[La informacion que se graba dentro del token(datos de User:id,name,apellido)es publico, no agregar informacion sencible como contraseñas], 
->FIRMA[Una palabra secreta, Firma con la que se crea el token es la misma con la que se valida si es el Usuario autenticado quien realiza una accion
->esa firma debe hacer match con la que se envia desde el User, se le agrega la fecha de expiracion(cada 2 horas o a eleccion)]
->Si el token es manipulado o cualquier letra manipulada ya no será valido

->https://jwt.io/
->Instalar: npm i jsonwebtoken
->Crear SECRET_JWT_SEED variable de entorno en .env Crear una palabra secreta, esta palabra debe ser secreta si alguien 
-> la tiene esta semilla va a poder firmar los tokens.
->Si se modifica la palabra secreta SECRET_JWT_SEED definida en .env automaticamente todos los token quedan invalidos, los user tendran que autenticarse de nuevo.  
->TOKEN GENERADO: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiR2Vyc29uIiwiaWF0IjoxNzE5OTgyMjE4LCJleHAiOjE3MTk5ODk0MTh9.NVXb5Owq_8hJ8HBSdtoOI5tfBtXEi6LtDYrD5_CsZG0

#####Configurar CORS -Para que el Frontend acceda al recurso API del backend
->enable-cors.org -> https://www.npmjs.com/package/cors  ->Instalar: npm i cors


##Seccion 24: Backend - Eventos del calendario - CRUD
#Instalar moment para validar Fechas: npm i moment


##Seccion: 25 Despliegue del backend a la nube -Railway
- Utlizar el correo de github para registrarse en Railway
- Subir el proyecto Backend 10-calendar-backend a Github ->
->Crear repositorio en github -> Mover nuestro proyecto a una carpeta nueva copy/paste ->
->crear el archivo .env.template para agregar solo las variables de entorno 
->mas no sus valores: 
	PORT 
	DB_CNN  
	SECRET_JWT_SEED
-> Crear archivo .gitignore y agregar: estos no se subiran a github
	.node_modules
	.env
->

->en la carpeta de nuestro proyecto -> clic derecho -> Git Bash Here o abrir la carpeta del
-> proyecto en VSC -> y ejecutar estos comandos:
->git init  //inicia el repositorio
->git add .  //agrega todo para subirlo a un stage y tomar una foto
->git commit -am "Subir a github app 10-calendar-backend"
--Conectar o subir el repositorio de git a github
->git remote add origin https://github.com/Gerson121295/Calendar-backend-MERN.git
->git branch -M main
->git push -u origin main   //subir el proyecto al repositorio de github


--Desplegar App 10-calendar-backend a Railway: https://railway.app/
->Crear cuenta en railway(usar cuenta de github para asi enlazar repositorios)
->Clic en Crear new Proyect -> Deploy from Github repo -> por primera vez aparece
-> se de configurar Railway App la cual dar clic en permitir o Only select repositories(elegí esta opcion)
->Luego seleccionar el repositorio copiar el nombre del proyecto de ->github(Calendar-backend-MERN) 
->a desplegar y pegarlo ->Install & Authorize ->Dar la contraseña de github
->luego clic de nuevo: Deploy from Github repo -> ahora seleccionar el proyecto seleccionadoCalendar-backend-MERN
->clic Add variables -> escanea nuestro codigo eliminar variable del puerto y definir la de DB_CNN y SECRET_JWT_SEED
->Otra forma de agregar las variables dar clic en RAW EDITOR Y pegar las variables de entorno definido en .env
->excepto por el puerto ese no, ese lo dará Railway
->Clic en Deploy en el apartado del nombre de la app -> ir a Settings ->Networking
->public Networking -> se definio el puerto 8080 ->clic en Generate Domain ->
->calendar-backend-mern-production-gep.up.railway.app

->Probar en Postman la app desplegada en railway
->Para todos los enpoints cambiar: localhost:4000/  por el dominio generado por railway: calendar-backend-mern-production-gep.up.railway.app
-> Login- Antes:POST localhost:4000/api/auth/    { "email": "gerson@gmail.com", "password":"123456" }
-> Login- Desplegado:POST https://calendar-backend-mern-production-gep.up.railway.app/api/auth
-> GetEvents - https://calendar-backend-mern-production-gep.up.railway.app/api/events

->SI da error en conexion a la BD ir a mongoDB atlas ->nuestro cluster -> Network Access 
-> clic en allow access form anywere  o agregar access list entry: 0.0.0.0


###Seccion 26 - MERN Calendario + Backend
-> Crear variables de entorno en app del frontend-> 10-calendar

->En carpeta helpers crear archivo: getEnvVariables.js para exportar las variables de entorno de .env

 export const getEnvVariables = () => {
    //importa todas las variables de entorno
    import.meta.env;
    return{
        ...import.meta.env //esparse y exporta las variables de entorno
    }
}

-> Crear archivo: .env  agregar:  VITE_API_URL=http://localhost:4000/api
-> Crear archivo: .env.template  agregar:  VITE_API_URL=
-> en archivo .gitignore agregar: .env  para no exportar a github este archivo
-> el archivo a exportar sera: .env.template en el cual los Usuario insertarán sus configuraciones.
-> Crear archivo: README.md 

->llamara la funcion getEnvVariables() en //router/AppRouter.jsx


####Axios - Configurar cliente para peticiones HTTP
->Instalar axios: npm i axios

->Forma de exportar archivo en el index.js cuando es export default archivo:

const calendarApi = axios.create({ baseURL: VITE_API_URL});
export default calendarApi;

-> Exportar en el index.js:  export { default as calendarApi } from './calendarApi';


###SweetAlert2 - Mostrar mensajes de alerta -> Instalar: 
-> Tablas en React - usar React Table.
-> https://www.npmjs.com/package/react-table
-> tutorial:
-> https://www.paradigmadigital.com/dev/agilizar-desarrollo-tablas-react/


->Cuando se esta editando un evento no se estan cargando 
->las fechas del evento correctamente. Mi solución.
->En el CalendarModal.js

-> Modificar los value de cada <DateTimePiker />
```
value={  (activeEvent) ? activeEvent.start : dateStart }
value={   (activeEvent) ? activeEvent.end : dateEnd }
```


##Seccion 28 Fin el MERN - Desplegarlo a produccion

--Recomendable tener aparte el Backend y Frontend
--Se puede desplegar el frontend dentro del backend por medio de la carpeta public

->Abrir el proyecto del frontend en Visual Studio Code y en la terminal ejecutar ->
->npm run build  //para realizar el proceso de optimizacion y construccion de nuestra App
->En el proyecto de react se crea carpeta dist ->tiene los assets(codigo de react) y index.html nuestro sitio web
->copiar la carpeta assets y el archivo: index.html y pegarlo en la carpeta public de la app del backend, 
->reemplazando esos archivos si en caso existieran ahi.
->Levantar el backend: npm run dev
-> abrir el navegador y ya no corre en: http://localhost:5173 ahora esta en: http://localhost:4000


##Desplegar backend y fronted a la nube
- En la app de react calendar -> ir al archivo: .env y agregar en la variable de entorno
-> VITE_API_URL=https://calendar-backend-mern-production-gep.up.railway.app/api  
->(la ruta del backend que se desplego en railway + /api).
--Como ya se tiene subido el backend en Railway por medio de GITHUB Proceder a subir los
->cambios realizados a github y automaticamente deberá desplegarse(ya que el frontend se encuentra
->en la carpeta public del backend.

-→nuestra app desplega: calendar-backend-mern-production-gep.up.railway.app


-- Codigo del Curso
https://github.com/Klerith/react-mern-calendar/tree/fin-seccion-29



























































